<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<title>tree</title>
<style>
/*  this disables the annoying double click highlighting of DIV blocks  */
div { outline-style:none;}
/*  this customizes the default scrollbar appearance */
::-webkit-scrollbar { width: 12pt; }
::-webkit-scrollbar-track {
    box-shadow: inset 0 0 15px grey; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb {
    background: OliveDrab; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb:hover {
    background: Olive; }
</style>
</head>
<body style="margin:0; padding:0;">
<script type="module">
import * as std from '../../runtime/beads_std.js';
import * as str from '../../runtime/beads_str.js';
import * as k   from '../../runtime/beads_k.js';
export const CODE_HASH= 0x5153a468;
const _M = "tree";
const _V = std.VAL;
std.rtl_init();
std.aaaa.main_init = main_init;
std.aaaa.main_module = "tree";
std.aaaa.main_drawer = new std.a_function("tree", "main_draw", main_draw);
//------- enums
const F_color_off=9007190915385613; std.g_enum_ss[9007190915385613]="color_off";
std.FIELDS[F_color_off] = true;
const F_nticks=9007190340680356; std.g_enum_ss[9007190340680356]="nticks";
std.FIELDS[F_nticks] = true;
const R_a_bulb=9007191419261671; std.g_enum_ss[9007191419261671]="a_bulb";
const F_color_on=9007191608599377; std.g_enum_ss[9007191608599377]="color_on";
std.FIELDS[F_color_on] = true;
const F_is_lit=9007190587435286; std.g_enum_ss[9007190587435286]="is_lit";
std.FIELDS[F_is_lit] = true;
//[reflAAA]
std.merge_lit(_M,0,std.META,_M, std.F_mod_const, "BIG_DOT", std.F_vv_typek, _V, std.TYPE_STR, std.POP, "DARK_GRAD", std.F_vv_rec, _V, "a_gradient", std.F_vv_typek, _V, std.TYPE_RECORD
, std.POP, "NH", std.F_vv_typek, _V, std.TYPE_NUM, std.POP, "NV", std.F_vv_typek, _V, std.TYPE_NUM, std.POP, "STAR", std.F_vv_typek, _V, std.TYPE_STR, std.POP, "TREE", std.F_vv_typek
, _V, std.TYPE_STR, std.POP, std.POP, std.F_mod_funcs, "blink_bulbs", std.F_vv_funck, _V, std.FK_CALC, std.POP, "main_draw", std.F_vv_funck, _V, std.FK_DRAW, std.POP, "main_init"
, std.F_vv_funck, _V, std.FK_CALC, std.POP, std.POP, std.F_mod_recs, "a_bulb", std.F_vv_fields, "color_off", std.F_vv_typek, _V, std.TYPE_COLOR, std.POP, "color_on", std.F_vv_typek
, _V, std.TYPE_COLOR, std.POP, "is_lit", std.F_vv_typek, _V, std.TYPE_YESNO, std.POP, "nticks", std.F_vv_typek, _V, std.TYPE_NUM, std.POP, std.POP, std.POP, std.POP, std.F_mod_vars
, "bulbs", std.F_vv_rec, _V, "a_bulb", std.F_vv_typek, _V, std.TYPE_RECORD);
//[reflZZZ]
//-------  func const
const blink_bulbs_F = new std.a_function("tree", "blink_bulbs", blink_bulbs);
//-------  top nodes
const TREE = "           Y\n          YYY\n          /_\\\n         /_R_\\\n        /_/_/_\\\n        /_\\G\\_\\\n       /_R_/_B_\\\n       /_\\_B_\\_\\\n      /_/G/_/R/_\\\n      /_\\_\\_B_\\_\\\n     /_G_/_/_/_/_\\\n     /_\\R\\_\\_B_G_\\\n    /_/_/_/_/_/_/_\\\n    /_\\_\\_\\R\\_\\_\\_\\\n   /_/R/_/_/_/_/R/_\\\n   /_\\_G_\\_\\_B_\\_\\_\\\n  /_/_/_/_B_/_/_G_/_\\\n         [___]"
;
const NH = 21;
const NV = 18;
const BIG_DOT = "⬤";
const STAR = "⭐";
const DARK_GRAD = new std.a_tree("tree","DARK_GRAD", std.NF_TOPLEVEL); std.merge_lit(_M, 33, DARK_GRAD, std.F_grad_shape, std.VAL, std.LINEAR_GRADIENT, std.F_grad_angle, std.
  VAL, std.GRAD_TO_RIGHT, std.F_grad_stops, 1, 1, std.VAL, 0, 2, std.VAL, std.BLACK, std.POP, 2, 1, std.VAL, 46, 2, std.VAL, std.MIDNIGHT_BLUE, std.POP, 3, 1, std.VAL, 54, 2
  , std.VAL, std.MIDNIGHT_BLUE, std.POP, 4, 1, std.VAL, 100, 2, std.VAL, std.BLACK, std.POP);
let bulbs = new std.a_tree("tree","bulbs", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);

//====================
//   main_draw
//====================
export function main_draw(b) {
k.k_root2(b);
k.k_enter(b);
  std.draw_rect(b, std.addr(b.extra, std.F_box), { grad:std.addr(DARK_GRAD) });
  const CELL_V = std.round_down(std.div(std.mul(b.bounds.height, 0.85), NV));
  const CELL_H = std.round(std.mul(CELL_V, 0.6));
  let x = 0;
  let y = 0;
  let size = std.U;
  let color = std.U;
  let r = new std.a_tree("tree","r"); std.merge_tree(_M, 92, std.solve_rect({ basis:std.addr(b.extra, std.F_box), pin:5, width:std.mul(CELL_H, NH), height:std.mul(CELL_V, NV
  ) }), std.addr(r));
  var b29 = k.k_create_layer(b,{ area:r });
  k.k_enter(b29);
    var loop65 = new std.a_loop({ from:1, to_:str.str_len(TREE) });
    while (loop65.next()) {
    var ix = loop65.index;
      let cc = str.subset(TREE, { from:ix, len:1 });
      var case66 = cc;
      if (case66 === "Y") {
        color = std.GOLD;
        cc = STAR;
        size = 0.5;
      } else if (case66 === "R" || case66 === "G" || case66 === "B") {
        color = std.getn(bulbs, cc, F_is_lit) === std.Y ? std.getn(bulbs, cc, F_color_on) : std.getn(bulbs, cc, F_color_off);
        cc = BIG_DOT;
        size = 0.6;
      } else {
        color = std.FOREST_GREEN;
        size = 0.8;
      }
      if (std.gt2(cc, " ")) {
        let box = new std.a_tree("tree","box"); std.merge_tree(_M, 114, std.solve_rect({ left:std.mul(x, CELL_H), top:std.mul(y, CELL_V), width:CELL_H, height:CELL_V }), std.addr(
        box));
        std.draw_str(b29, std.addr(box), cc, { size:std.mul(CELL_V, size), shrink:std.N, color:color, font:"_typewriter" });
      }
      if (std.eq2(cc, "\n")) {
        y = std.add(y, 1);
        x = 0;
      } else {
        x = std.add(x, 1);
      }
    }
  k.k_leave(b29);
k.k_leave(b);
}


//====================
//   blink_bulbs
//====================
function blink_bulbs() {
  var loop67 = new std.a_loop({ across:std.addr(bulbs) });
  while (loop67.next()) {
  var bulb = loop67.path.clone();
    std.tree_sub(_M, 65, 1, std.addr(bulb, F_nticks));
    if (std.le2(std.getn(bulb, F_nticks), 0)) {
      std.toggle(_M, 69, std.addr(bulb, F_is_lit));
      std.path_setv(_M, 73, std.addr(bulb, F_nticks), std.getn(bulb, F_is_lit) === std.Y ? std.random_int(10, 20) : std.random_int(2, 8));
    }
  }
}


//====================
//   main_init
//====================
export function main_init() {
  std.copy_tree(_M, 51, std.tree_lit(_M, 51, F_nticks, std.VAL, 8, F_is_lit, std.VAL, std.Y, F_color_on, std.VAL, std.RED, F_color_off, std.VAL, std.MAROON), std.addr(bulbs, 
  "R"));
  std.copy_tree(_M, 52, std.tree_lit(_M, 52, F_nticks, std.VAL, 8, F_is_lit, std.VAL, std.Y, F_color_on, std.VAL, std.LIME_GREEN, F_color_off, std.VAL, std.DARK_GREEN), std.addr(
  bulbs, "G"));
  std.copy_tree(_M, 53, std.tree_lit(_M, 53, F_nticks, std.VAL, 8, F_is_lit, std.VAL, std.Y, F_color_on, std.VAL, std.DODGER_BLUE, F_color_off, std.VAL, std.BLUE), std.addr(
  bulbs, "B"));
  std.loom_timer(blink_bulbs_F, { rate:12, delay:0.3, reps:10000 });
}

main_init();
k.rebuild_all();

</script>
</body>
</html>
