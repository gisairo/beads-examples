<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<title>calculator</title>
<style>
/*  this disables the annoying double click highlighting of DIV blocks  */
div { outline-style:none;}
/*  this customizes the default scrollbar appearance */
::-webkit-scrollbar { width: 12pt; }
::-webkit-scrollbar-track {
    box-shadow: inset 0 0 15px grey; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb {
    background: OliveDrab; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb:hover {
    background: Olive; }
</style>
</head>
<body style="margin:0; padding:0;">
<script type="module">
import * as std from '../../runtime/beads_std.js';
import * as str from '../../runtime/beads_str.js';
import * as k   from '../../runtime/beads_k.js';

export const CODE_HASH = 0xc0ab13e9;
export const M_calculator = 9007192728595263;  std.g_enum_ss[9007192728595263] = "calculator";
const M = M_calculator;
std.rtl_init();
std.aaaa.main_init = main_init;
std.aaaa.main_module = M;
std.aaaa.main_drawer = new std.a_function("calculator", "main_draw", main_draw);
std.setv(0,0, std.META, M, "calculator");
std.setv(0,0, std.META, M, std.F_mod_funcs, 169, "do_period");
std.setv(0,0, std.META, M, std.F_mod_funcs, 154, "sign_change");
std.setv(0,0, std.META, M, std.F_mod_funcs, 176, "do_equals");
std.setv(0,0, std.META, M, std.F_mod_funcs, 47, "main_draw");
std.setv(0,0, std.META, M, std.F_mod_funcs, 219, "add_digit");
std.setv(0,0, std.META, M, std.F_mod_funcs, 142, "eval");
std.setv(0,0, std.META, M, std.F_mod_funcs, 58, "d_result");
std.setv(0,0, std.META, M, std.F_mod_funcs, 130, "do_percent");
std.setv(0,0, std.META, M, std.F_mod_funcs, 229, "do_arith");
std.setv(0,0, std.META, M, std.F_mod_funcs, 150, "do_clear");
std.setv(0,0, std.META, M, std.F_mod_funcs, 73, "d_keys");
std.setv(0,0, std.META, M, std.F_mod_funcs, 81, "d_keygrid");
std.setv(0,0, std.META, M, std.F_mod_funcs, 42, "main_init");
std.setv(0,0, std.META, M, std.F_mod_funcs, 200, "arithmetic");
//------- enums
const F_ss = 9007193665285566;  std.g_enum_ss[9007193665285566] = "ss";
std.FIELDS[F_ss] = true;
const F_terms = 9007192892604483;  std.g_enum_ss[9007192892604483] = "terms";
std.FIELDS[F_terms] = true;
const F_op = 9007193787363399;  std.g_enum_ss[9007193787363399] = "op";
std.FIELDS[F_op] = true;
const F_chain_val = 9007192097512801;  std.g_enum_ss[9007192097512801] = "chain_val";
std.FIELDS[F_chain_val] = true;
const R_a_state = 9007192953576597;  std.g_enum_ss[9007192953576597] = "a_state";
const R_a_term = 9007193840001586;  std.g_enum_ss[9007193840001586] = "a_term";
const F_fresh = 9007192114719380;  std.g_enum_ss[9007192114719380] = "fresh";
std.FIELDS[F_fresh] = true;
const F_chain_op = 9007190437095029;  std.g_enum_ss[9007190437095029] = "chain_op";
std.FIELDS[F_chain_op] = true;
const F_termx = 9007193043603054;  std.g_enum_ss[9007193043603054] = "termx";
std.FIELDS[F_termx] = true;
//-------  func const
const do_period_F = new std.a_function("calculator", "do_period", do_period);
const do_equals_F = new std.a_function("calculator", "do_equals", do_equals);
const d_result_F = new std.a_function("calculator", "d_result", d_result);
const do_percent_F = new std.a_function("calculator", "do_percent", do_percent);
const do_clear_F = new std.a_function("calculator", "do_clear", do_clear);
const d_keys_F = new std.a_function("calculator", "d_keys", d_keys);
const d_keygrid_F = new std.a_function("calculator", "d_keygrid", d_keygrid, track_d_keygrid);
const d_keygrid_cell_F = new std.a_function("calculator", "d_keygrid_cell", d_keygrid_cell);
//-------  top nodes
const C_OP = 0x3E424D;
const C_DIGIT = 0x6E6E6E;
const C_ARITH = 0x1A4C6E;
const KEYCAPS = new std.a_tree("calculator","KEYCAPS"); std.merge_tree(M, 14, std.matrix_lit(M, 14, 
  1, std.VAL, "C", 
  2, std.VAL, "±", 
  3, std.VAL, "%", 
  4, std.VAL, "÷", 
  5, std.VAL, "1", 
  6, std.VAL, "2", 
  7, std.VAL, "3", 
  8, std.VAL, "x", 
  9, std.VAL, "4", 
  10, std.VAL, "5", 
  11, std.VAL, "6", 
  12, std.VAL, "−", 
  13, std.VAL, "7", 
  14, std.VAL, "8", 
  15, std.VAL, "9", 
  16, std.VAL, "+", 
  17, std.VAL, "", 
  18, std.VAL, "0", 
  19, std.VAL, ".", 
  20, std.VAL, "="), std.addr(KEYCAPS));
const KEYCOLORS = new std.a_tree("calculator","KEYCOLORS"); std.merge_tree(M, 20, std.matrix_lit(M, 20, 
  1, std.VAL, C_OP, 
  2, std.VAL, C_OP, 
  3, std.VAL, C_OP, 
  4, std.VAL, C_ARITH, 
  5, std.VAL, C_DIGIT, 
  6, std.VAL, C_DIGIT, 
  7, std.VAL, C_DIGIT, 
  8, std.VAL, C_ARITH, 
  9, std.VAL, C_DIGIT, 
  10, std.VAL, C_DIGIT, 
  11, std.VAL, C_DIGIT, 
  12, std.VAL, C_ARITH, 
  13, std.VAL, C_DIGIT, 
  14, std.VAL, C_DIGIT, 
  15, std.VAL, C_DIGIT, 
  16, std.VAL, C_ARITH, 
  17, std.VAL, C_OP, 
  18, std.VAL, C_DIGIT, 
  19, std.VAL, C_OP, 
  20, std.VAL, C_ARITH), std.addr(KEYCOLORS));
const SPACING = 3;
const HAIR = " ";
let g = new std.a_tree("calculator","g", std.NF_STATEFUL|std.NF_LOGGED);
const V_calculator_g = 9007192978709502;  std.g_enum_ss[9007192978709502] = "g";
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_val, std.addr(g));
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_type, std.TYPE_TREE);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_rec, R_a_state);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_terms, std.F_v_type, std.TYPE_TREE);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_terms, std.F_v_dim, 1);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_terms, std.F_v_rec, R_a_term);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_terms, std.F_v_fields, F_ss, std.F_v_type, std.TYPE_STR);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_terms, std.F_v_fields, F_op, std.F_v_type, std.TYPE_STR);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_termx, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_chain_op, std.F_v_type, std.TYPE_STR);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_chain_val, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_calculator_g, std.F_v_fields, F_fresh, std.F_v_type, std.TYPE_YESNO);

//====================
//   d_keygrid
//====================
function d_keygrid(b) {
k.k_enter(b);
k.div_begin(b, true, false, false, false);
  k.div_spa(b, 0, SPACING, std.pt);
  var loop2 = new std.a_loop({ limit:4 });
  while (loop2.next()) {
    k.div_add(b, std.U, 0, 10, std.al, d_keygrid_cell_F, 0);
    k.div_spa(b, 0, SPACING, std.pt);
  }
  k.div_spa(b, 1, SPACING, std.pt);
  var loop3 = new std.a_loop({ limit:5 });
  while (loop3.next()) {
    k.div_add(b, std.U, 1, 10, std.al, d_keygrid_cell_F, 0);
    k.div_spa(b, 1, SPACING, std.pt);
  }
  k.div_end(b);
  k.draw_grid(b);
k.k_leave(b);
}


//====================
//   d_keygrid_cell
//====================
function d_keygrid_cell(b) {
  k.k_enter(b);
  std.draw_rect(b, std.addr(b.extra, std.F_box), { fill:std.get_generic(KEYCOLORS, std.getn(b.extra, std.F_cell_seq)), corner:std.pt_to_dots(b, 6) });
  std.draw_str(b, std.addr(b.extra, std.F_box), std.get_generic(KEYCAPS, std.getn(b.extra, std.F_cell_seq)), { size:b.bounds.height, color:std.WHITE });
  k.k_leave(b);
}

//====================
//   track_d_keygrid
//====================
function track_d_keygrid(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    var case4 = std.getn(b.extra, std.F_cell_seq);
    if (case4 === 1) {
      do_clear();
    } else if (case4 === 2) {
      sign_change(std.getn(g, F_termx));
    } else if (case4 === 3) {
      do_percent();
    } else if (case4 === 4 || case4 === 8 || case4 === 12 || case4 === 16) {
      do_arith(std.get_generic(KEYCAPS, std.getn(b.extra, std.F_cell_seq)));
    } else if (case4 === 17) {
    } else if (case4 === 19) {
      do_period();
    } else if (case4 === 20) {
      do_equals();
    } else {
      add_digit(std.get_generic(KEYCAPS, std.getn(b.extra, std.F_cell_seq)));
    }
  return std.Y;
  }
  return std.N;
}

//====================
//   d_keys
//====================
function d_keys(b, totwidth) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, std.U, 0, totwidth, std.px, d_keygrid_F, 0);
  k.div_spa(b, 0, 10, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_result
//====================
function d_result(b) {
k.k_enter(b);
  std.draw_rect(b, std.addr(b.extra, std.F_box), { fill:0xD161F });
  let s = "";
  var loop5 = new std.a_loop({ across:std.addr(g, F_terms) });
  while (loop5.next()) {
  var i = loop5.index;
    s = std.cat(s, std.gets(g, F_terms, i, F_ss));
    if (std.gets(g, F_terms, i, F_op) !== null) {
      s = std.cat(s, HAIR, std.gets(g, F_terms, i, F_op), HAIR);
    }
  }
  if (std.eq2(s, "")) {
    s = "0";
  }
  std.draw_str(b, std.addr(b.extra, std.F_box), s, { size:std.mul(b.bounds.height, 0.5), just:std.RIGHT, indent:std.pt_to_dots(b, 20), color:std.WHITE });
k.k_leave(b);
}


//====================
//   main_draw
//====================
export function main_draw(b) {
k.k_root2(b);
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  let cellsize = std.gt2(b.bounds.width, b.bounds.height) ? std.div(b.bounds.height, 8) : std.div(b.bounds.width, 4);
  let result_v = std.mul(cellsize, 2);
  let keys_v = std.mul(cellsize, 5);
  let keys_maxh = std.min(b.bounds.width, std.mul(cellsize, 8));
  std.draw_rect(b, std.addr(b.extra, std.F_box), { fill:0x121F30 });
  k.div_spa(b, 1, 10, std.al);
  k.div_add(b, std.U, 1, result_v, std.px, d_result_F, 0);
  k.div_add(b, std.U, 1, keys_v, std.px, d_keys_F, 0, [keys_maxh]);
  k.div_spa(b, 1, 10, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_digit
//====================
function add_digit(digit) {
  if (std.getn(g, F_fresh) === std.Y || std.eq2(std.gets(g, F_terms, std.getn(g, F_termx), F_ss), "0")) {
    std.path_setv(M, 225, std.addr(g, F_terms, std.getn(g, F_termx), F_ss), "");
  }
  std.tree_cat(M, 226, digit, std.addr(g, F_terms, std.getn(g, F_termx), F_ss));
  std.path_setv(M, 227, std.addr(g, F_fresh), std.N);
}


//====================
//   arithmetic
//====================
function arithmetic(operand, term1, term2) {
  let result = std.U;
  var case6 = operand;
  if (case6 === "+") {
    result = std.add(term1, term2);
  } else if (case6 === "−") {
    result = std.sub(term1, term2);
  } else if (case6 === "x") {
    result = std.mul(term1, term2);
  } else if (case6 === "÷") {
    result = std.div(term1, term2);
  } else {
    result = std.ERR;
  }
  return result;
}


//====================
//   do_arith
//====================
function do_arith(operand) {
  if (std.eq2(std.gets(g, F_terms, std.getn(g, F_termx), F_ss), "")) {
    if (std.eq2(std.getn(g, F_termx), 1)) {
      return;
    }
    std.path_setv(M, 240, std.addr(g, F_terms, std.sub(std.getn(g, F_termx), 1), F_op), operand);
  } else {
    std.path_setv(M, 243, std.addr(g, F_terms, std.getn(g, F_termx), F_op), operand);
    std.tree_add(M, 244, 1, std.addr(g, F_termx));
    std.path_setv(M, 245, std.addr(g, F_terms, std.getn(g, F_termx), F_ss), "");
  }
}


//====================
//   do_clear
//====================
function do_clear() {
  std.path_setv(M, 152, std.addr(g, F_terms, std.getn(g, F_termx), F_ss), "");
}


//====================
//   do_equals
//====================
function do_equals() {
  let val = eval_(1);
  let val2 = std.U;
  if (std.lt2(std.tree_count(std.addr(g, F_terms)), 2)) {
    if (std.gets(g, F_chain_op) !== null) {
      val = arithmetic(std.gets(g, F_chain_op), val, std.getn(g, F_chain_val));
    }
  } else {
    var loop7 = new std.a_loop({ from:1 });
    while (loop7.next()) {
    var tx = loop7.index;
      if (std.and4(std.ne4(std.gets(g, F_terms, std.add(tx, 1), F_ss), ""), std.ne4(std.gets(g, F_terms, tx, F_op), std.U)) !== std.Y)
        break;
      val2 = eval_(std.add(tx, 1));
      std.path_setv(M, 190, std.addr(g, F_chain_op), std.gets(g, F_terms, tx, F_op));
      std.path_setv(M, 191, std.addr(g, F_chain_val), val2);
      val = arithmetic(std.gets(g, F_chain_op), val, val2);
    }
  }
  std.trunc_tree(M, 195, std.addr(g, F_terms));
  std.path_setv(M, 196, std.addr(g, F_terms, 1, F_ss), str.to_str(val));
  std.path_setv(M, 197, std.addr(g, F_termx), 1);
  std.path_setv(M, 198, std.addr(g, F_fresh), std.Y);
}


//====================
//   do_percent
//====================
function do_percent() {
  if (std.ne2(std.gets(g, F_terms, std.getn(g, F_termx), F_ss), "")) {
    if (std.gt2(std.getn(g, F_termx), 1)) {
      std.path_setv(M, 136, std.addr(g, F_terms, std.getn(g, F_termx), F_ss), str.to_str(std.div(std.mul(eval_(std.getn(g, F_termx)), eval_(std.sub(std.getn(g, F_termx), 1))), 100
      )));
    } else {
      std.path_setv(M, 139, std.addr(g, F_terms, std.getn(g, F_termx), F_ss), str.to_str(std.div(eval_(std.getn(g, F_termx)), 100)));
    }
    std.path_setv(M, 140, std.addr(g, F_fresh), std.Y);
  }
}


//====================
//   do_period
//====================
function do_period() {
  let list = new std.a_tree("calculator","list");
  str.str_find(M, 172, std.gets(g, F_terms, std.getn(g, F_termx), F_ss), ".", std.addr(list));
  if (std.eq2(std.tree_count(std.addr(list)), 0)) {
    add_digit(".");
  }
}


//====================
//   eval
//====================
function eval_(termx) {
  let ss = std.gets(g, F_terms, termx, F_ss);
  if (std.eq2(ss, "")) {
    return 0;
  }
  return str.to_num(ss);
}


//====================
//   main_init
//====================
export function main_init() {
  std.path_setv(M, 43, std.addr(g, F_terms, 1, F_ss), "");
  std.path_setv(M, 44, std.addr(g, F_termx), 1);
  std.path_setv(M, 45, std.addr(g, F_fresh), std.Y);
}


//====================
//   sign_change
//====================
function sign_change(tx) {
  let old = std.gets(g, F_terms, tx, F_ss);
  if (std.eq2(old, "")) {
    if (std.gt2(tx, 1)) {
      sign_change(std.sub(tx, 1));
    }
  } else if (str.str_begins(old, "-") === std.Y) {
    std.path_setv(M, 165, std.addr(g, F_terms, tx, F_ss), str.str_subset(old, { from:2 }));
  } else {
    std.path_setv(M, 167, std.addr(g, F_terms, tx, F_ss), std.cat("-", old));
  }
}

main_init();
k.rebuild_all();

</script>
</body>
</html>
